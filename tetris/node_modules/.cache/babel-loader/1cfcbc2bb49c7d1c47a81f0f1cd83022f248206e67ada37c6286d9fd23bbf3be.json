{"ast":null,"code":"var global = require('./$.global'),\n  core = require('./$.core'),\n  ctx = require('./$.ctx'),\n  PROTOTYPE = 'prototype';\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F,\n    IS_GLOBAL = type & $export.G,\n    IS_STATIC = type & $export.S,\n    IS_PROTO = type & $export.P,\n    IS_BIND = type & $export.B,\n    IS_WRAP = type & $export.W,\n    exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),\n    target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],\n    key,\n    own,\n    out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? function (C) {\n      var F = function (param) {\n        return this instanceof C ? new C(param) : C(param);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n      // make static versions for prototype methods\n    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n  }\n};\n// type bitmap\n$export.F = 1; // forced\n$export.G = 2; // global\n$export.S = 4; // static\n$export.P = 8; // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;","map":{"version":3,"names":["global","require","core","ctx","PROTOTYPE","$export","type","name","source","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","exports","target","key","own","out","C","param","Function","call","module"],"sources":["/Users/Pajamas/Project/tetris/node_modules/babel-runtime/node_modules/core-js/library/modules/$.export.js"],"sourcesContent":["var global    = require('./$.global')\n  , core      = require('./$.core')\n  , ctx       = require('./$.ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(param){\n        return this instanceof C ? new C(param) : C(param);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n  }\n};\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}